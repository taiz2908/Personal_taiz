Ref: 
- https://www.youtube.com/watch?v=bhBSlnQcq2k&t=154s
- https://www.youtube.com/watch?v=1eVy_iWrc20&t=4403s

- https://www.youtube.com/watch?v=41UBe7J4oQo&list=PLKDtzUTXWwwF6e0UFWxpylEJgrKm0dEoI: docker containers namespaces
- https://www.youtube.com/watch?v=pg19Z8LL06w Docker Crash Course for Absolute Beginners 
- https://www.youtube.com/watch?v=rLrISSCXiMo The 21 Docker Commands Every Developer Needs to Know

Docker Interview Qus:
- https://www.interviewbit.com/docker-interview-questions/

--------------------What is Docker? -------------------------------------
 - Docker is a tool for running application in an isolated environment. 
 - It's similar to virtual machine.
 - Standard for software deployment. 

Now Docker is paid , we can use dockerD.

--------------------Container vs Virtual Machine-----------------------------------
Containers:
 - Containers are an abstraction at the app layer that packages code & dependecies together. 
 - Multiple containers can run on the same machine & share the OS Kernel with other container. 

Ex:
----[Aap A] [Aap B]  [Aap C]
------Docker-----------
------Host OS----------
------Infra------------

Virtual Machine:
 - Virtual machines are an abstraction of physical hardware turning one server into many servers.
 - Each VM includes full copy of an OS system / Dedicated OS, necessary binaries & libraries- taking up ten's of GB's
 - Slow to boot. 

Ex:
 [-----VM1----] [VM2]   [VM3]
 -----AAP1---  --AAP2--  
 [GUEST OS]    [GUEST OS]
 -----Hypervisor--------------------------
 -----Infra-------------------------------

Benefits of Container:
- Run container in sec instead of minutes. 
- Less resource result less disk spaces. 
- Less Memory i.e. light weight 
- Doesn't need full OS. 
- High Performance 
- Deployment 
- Testing (Locally)

---------------------------- Docker Images & Containers -----------------------------------
Images:
 - Image is a template for creating an environment of our choice. 
 - It's a snapshot.
 - Has everything to run an application. 
 - OS , software , app code etc .

Containers:
 - Running instance of an image. 
 - 
Note: We can't modify docker images, Can convert into container's and within container we can do the required changes. 

Docker Daemon :
- It listen docker api request and manages docker objects such as images, container, volumes etc.
- Also it can communicate with other docker deamon to manage services.

------------------------COMMAND'S-------------------------------------
Images:
 - docker images / docker image ls
 - docker run 
 - docker tag
 - docker pull
 - docker push
 - docker rmi <image_name>
 - docker history <image_name> -->can see history of the image(WORKDIR,CMD,ADD,ENV,EXPOSE,COPY)

Container's:
 - docker container ls 
 - docker ps ,to show running container 
 - docker ps --help
 - docker ps -a / docker ps -aq: to show running as well as stop container 
 - docker start 
 - docker stop: stopping the running container,send the signal SIGTERM.
 - docker kill: Kill one or more container, send the signal SIGKILL.
 - docker rm 
 - docker attach
 - docker inspect
 - docker logs: Want to view the logs of the container. 
 - docker stats --all / <containerID> : to check the container CPU Usage's
 - docker commit
 - docker top 

Ex: Pulling an image from hub.docker.com , Tomcat Image
# docker pull tomcat
# docker images
# docker run -d --name appserver -p 8090:8080 tomcat 
# docker exec -it appserver /bin/bash or, bash
# cd webapps.dist/
# cp -R * ../webapps/

------: To Delete Container: ----------
docker stop <containerID>
docker stop $(docker ps -q) , stop multiple container
docker rm $(docker ps -aq) , delete all container
docker rmi $(docker images -q) , remove multiple images
docker image rm <imageID>
docker rm <containerID> --force / docker rm -f <container_name>, forcefully delete a container
docker system prune -f , Remove all unused containers, networks, images (both dangling and unreferenced),optionally, volumes.

------------------------------ DOCKER PORT MAPPING ------------------------------------------------
TCP:1-65535 port range for the soruce-port 
8080 -->inside the host m/c
80 --> application running inside the container 
If anyone calls 8080, internally its forwards to port 80. 

Ex: Exposing Ports 
 docker pull nginx
 docker run -d -p 8080:80 nginx:latest
 docker run -d -p 8090:27017 mongodb:latest
How to Access:
 localhost:8080
 localhost:8090
127.0.0.1 --> localhost port

Ex: Exposing multiple ports.
 #docker run -d -p 8080:80 -p 9090:80 nginx:latest

---------------------------------NAMING A CONTAINER---------------------------------------------
 # docker run --name <name_of_the_container> -d -p 8080:80 nginx:latest

 # docker ps --format="ID\t{{.ID}}\nNAME\t{{.Names}}\nIMAGE\t{{.Image}}\nPORTS\t{{.Ports}}\nCOMMAND\t{{.Command}}\nCREATED\t{{.CreatedAt}}\nSTATUS\t{{.Status}}\n"

 # export FORMAT="ID\t{{.ID}}\nNAME\t{{.Names}}\nIMAGE\t{{.Image}}\nPORTS\t{{.Ports}}\nCOMMAND\t{{.Command}}\nCREATED\t{{.CreatedAt}}\nSTATUS\t{{.Status}}\n"

 # docker ps --format=$FORMAT

--------------------------------: DOCKER VOLUMES :------------------------
Allowing share of data, files & folders between hosts & containers, and between containers. 
#docker volume ls
#docker volume create <volume_name>
#docker volume rm <volume_name>
 cd /var/lib/docker/volumes/<volume_name>/_data

1. Copy the data from local to nginx container: 
  #docker run --name website -v <desktop_path>:</usr/share/nginx/html> -d -p 8080:80 nginx:latest
  #docker exec -it <containername/containerID> bash
  # ctrl+d : come outside of the container.
  # ctrl+p+q: come outside of the container without stopping. 
  # ctrl+c: kill the process

2. Volumes between containers:
  docker run --help: show all commands
  docker run --name website-copy --volumes-from website -d -p 8081:80 nginx

--------------------------------: DOCKERFILE :----------------------------
By using dockerfile we can create our own image & always create a dockerfile within the folder
Below's are the set of instructions using in dockerfile:

 MAINTAINER: Author name / emailid
 FROM: The base image to use in the build Ubuntu, Redis, MySQL, etc.
 RUN: executes a command,It is used to tell the container what to do after creating the container from the image. 
 Such as, apk add â€”update-redis.
 EXPOSE: opens a port 
 COPY: only perform copy i.e, copy a file from host 
 ADD: copy the files from the remote source i.e, from website,
 It downloads tar, zip, or web file and extracts and copies inside of our image.
 ENV: gets an env variable 
 WORKDIR: Going to create a workdir inside of the container 
 USER: instruction sets the user name 
 ENTRYPOINT: it executes as it is & if we provide any new arguments its appended at the end of the instruction. 
 CMD: it's failed as its try to replaced the arg/instruction to httpd.

------------------------ ENTERYPOINT vs CMD ----------------------
ENTRYPOINT has two forms:
 - The exec form, which is the preferred form: ENTRYPOINT ["executable", "param1", "param2"]
 - The shell form: ENTRYPOINT command param1 param2

The CMD instruction has three forms:
- CMD ["executable","param1","param2"] (exec form, this is the preferred form)
- CMD command param1 param2 (shell form)
- CMD ["param1","param2"] (as default parameters to ENTRYPOINT)

Major difference is:
1. In ENTRYPOINT it executes as it is & if we provide any new arguments its appended at the end of the instruction. 

Ex: CMD
 FROM centos:centos7
 CMD ["yum", "-y", "install", "git"]
 docker build -t demo .
 docker run -d --name demo httpd : it's failed as its try to replaced the arg/instruction to httpd.

Ex: ENTRYPOINT
 FROM centos:centos7
 ENTRYPOINT ["yum", "-y", "install", "git"]
 docker build -t demo .
 docker run -d --name demo httpd tree telnet : it's work and its appned at the end of the arg.

Note: We can use both CMD & ENTRYPOINT in a dockerfile.
Ex:
 FROM centos:centos7
 ENTRYPOINT ["yum", "-y", "install"]
 CMD ["git"]
 docker build -t demo .
 docker run -d --name demo tree httpd telnet
 
-----------------------------------------------------------------
Ex: 1, Building docker file & create a nginx image. 
 mkdir folder_name
 docker build --help
 vi Dockerfile
 FROM nginx:latest
 ADD . /usr/share/nginx/html

 # docker build -t website:latest .
 # docker image ls 
 # docker run --name website -p 8080:80 -d website:latest
 # docker ps --format=$FORMAT

Ex: 2, Nodejs & Express js
Files Present in Source code:
index.js
package-lock.json
package.json
Dockerfile
.dockerignore

 FROM node:latest
 WORKDIR /app
 ADD . .
 RUN npm install
 CMD node index.js

Ex: 3, Deploying springboot app in tomcat server.
 Ref: https://iamvickyav.medium.com/deploying-spring-boot-war-in-tomcat-based-docker-2b689b206496

 FROM tomcat:lates8.5-jdk11-openjdk-slim
 RUN rm -rf /usr/local/tomcat/webapps/*
 ADD target/sample.war /usr/local/tomcat/webapps
 EXPOSE 8080
 CMD ["catalina.sh", "run"]

-------------------- .dockerignore -----------------------------
 We should ignore files /folders . 
 How to add ? we need to create .dockerignore 
 file.txt
 Dockerfile
 .git
 *.java

--------------------- CACHING & LAYERS ------------------------
When ever source code modify with new code caching & layers added as its not a good practice. 
How to improve this in Dockerfile ? 
Just thinking what will change & what'll not change.

FROM node:latest
WORKDIR /app
ADD package*.json ./
RUN npm install
ADD . .
CMD node index.js

---------------------: How to Improve our Image sizes with Docker :--------
One way by using Alpine linux distribution Method. 
https://www.alpinelinux.org/

docker pull node:lts-alpine
docker pull nginx:alpine

Ex: Using in a Dockerfile: 
 FROM node:alpine
 WORKDIR /app
 ADD package*.json ./
 RUN npm install
 ADD . .
 CMD node index.js

----------------: Tags, Versioning & Tagging :----------------------------
1. Allows you to control image versions
2. Avoids breaking changes
3. Safe 

Ex: Suppose two images there but not sure with version. 
# docker pull node:alpine ---> version using 8.0
# docker pull node:alpine ---> version using 12.0

Ex: Using in a Dockerfile: 
 FROM node:1.71.2-alpine
 WORKDIR /app
 ADD package*.json ./
 RUN npm install
 ADD . .
 CMD node index.js

--------: Tagging our Own Images :-------------------------------
# docker build -t api-website:latest .
# docker tag api-website:latest api-website:1 , changing a latest tag to 1 / renaming a tag

--------: Running Containers with different Tags: ----------------
# docker run --name api-website -p 8080:80 -d api-website:latest
# docker run --name api-website-1 -p 8081:80 -d api-website:1
# docker images
 api-website:latest
 api-website:1

----------: Docker Registries: ---------------------------
Docker Hub
Amazon ECR
QUAY.IO
1. Private 
2. Public
- Highly scalable server side application that stores and lets you distribute docker images. 
- Used in CI/CD Pipelines.
- Running the applications. 

# docker push amigoscode/website:tagname
 amigoscode: account name
 website: repo name within docker registries

1) Taging the Image according to the docker_hub_account_&_repo_name.
 # docker tag api-website:latest amigoscode/website:latest
 # docker tag api-website:1 amigoscode/website:1
2) Pushing the Image to docker hub
 # docker push amigoscode/website:latest
 # docker push amigoscode/website:1
3) Pulling our own Images
 # docker pull amigoscode/website:latest
 # docker pull amigoscode/website:1
4) Converting image to container 
 # docker run --name website-new -p 9000:80 -d amigoscode/website:latest
 # docker run --name website-new-1 -p 9001:80 -d amigoscode/website:1

-------------: DEBUGGING THE CONTAINERS :-----------
 1) --------------: Docker Inspect :----------------------------------------
 - Use for debugging the container . 
 - Following info we can see
 - Portbinding, Restart Policy, Volumne driver, Cpu period, Memory swap, Networks, IP address etc...

# docker inspect <containerID_or_conatinerNAME> , gives a JSON format

 2) -------------: Docker Logs :------------------------------------
 - Want to view the logs of the container. 
 # docker logs --help
 # docker logs <containerID_or_conatinerNAME>
 # docker logs <containerID> | tail , to see the last logs
 # docker logs <containerID> | --tail 3 , to see the last three line logs

 Ex: docker exec:
 # docker exec --help
 # docker exec -it <containerID_or_conatinerNAME> /bin/bash --> failed to create the container.
 # docker inspect <containerID_or_conatinerNAME> , search in cmd and able to see command. 
 # docker exec -it <containerID_or_conatinerNAME> /bin/sh , enter inside the container. 
  ls -al 
-------------: Docker Container IP :---------------
By using # docker inspect <containerID>
172.17.0.1
172.17.0.2
---------------: Docker Compose :--------------------------------
- It is a YAML file consisting of all the details regarding various services, networks, and volumes
 that are needed for setting up the Docker-based application. 
- So, docker-compose is used for creating multiple containers, host them and establish communication between them.
- For the purpose of communication amongst the containers, ports are exposed by each and every container.

---------------: Docker Networking :-----------------------------
1. Bridge
2. Host
3. None
4. Overlay
5. Macvlan
